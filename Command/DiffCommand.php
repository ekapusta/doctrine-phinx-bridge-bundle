<?php

namespace Ekapusta\DoctrinePhinxBridgeBundle\Command;

use Doctrine\Bundle\DoctrineBundle\Command\Proxy\DoctrineCommandHelper;
use Doctrine\DBAL\Migrations\Configuration\Configuration;
use Doctrine\DBAL\Migrations\Provider\OrmSchemaProvider;
use Doctrine\DBAL\Migrations\Tools\Console\Command\DiffCommand as BaseDiffCommand;
use Doctrine\DBAL\Migrations\Tools\Console\Helper\MigrationDirectoryHelper;
use Phinx\Util\Util;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;

/**
 * Generate phinx migrations from doctrine schema diffs
 */
class DiffCommand extends BaseDiffCommand
{
    private $version;

    protected function configure()
    {
        parent::configure();

        $this->version = date('YmdHis');
        $this
            ->setName('doctrine:migrations:diff:phinx')
            ->addOption('em', null, InputOption::VALUE_OPTIONAL, 'The entity manager to use for this command.')
            ->addOption('template', 't', InputOption::VALUE_OPTIONAL, 'Use an alternative template.', $this->getDefaultTemplatePath())
            ->addArgument('classname', InputArgument::OPTIONAL, 'Migration class name to use instead of autogenerated.', 'AutoMigration' . $this->version)
        ;
    }

    protected function getDefaultTemplatePath()
    {
        return dirname(__DIR__) . '/Resources/views/phinx.template.php.dist';
    }

    protected function loadTemplate(InputInterface $input)
    {
        return file_get_contents($input->getOption('template'));
    }

    public function execute(InputInterface $input, OutputInterface $output)
    {
        // Configure entity manager
        DoctrineCommandHelper::setApplicationEntityManager($this->getApplication(), $input->getOption('em'));
        $configuration = $this->getMigrationConfiguration($input, $output);

        // Configure migrations directory
        $dir = $this->getContainer()->getParameter('doctrine_migrations.dir_name');
        if (!file_exists($dir)) {
            mkdir($dir, 0777, true);
        }
        $configuration->setMigrationsDirectory($dir);

        // Configure namespace
        if (!$configuration->getMigrationsNamespace()) {
            $configuration->setMigrationsNamespace('Phinx\Migration');
        }

        // Configure migrations table
        $configuration->setMigrationsTableName($this->getContainer()->getParameter('doctrine_migrations.table_name'));

        // Process
        $connection = $configuration->getConnection();
        $platform   = $connection->getDatabasePlatform();

        if ($filterExpression = $input->getOption('filter-expression')) {
            $connection->getConfiguration()->setFilterSchemaAssetsExpression($filterExpression);
        }

        $fromSchema = $connection->getSchemaManager()->createSchema();
        $toSchema   = (new OrmSchemaProvider($this->getHelper('entityManager')->getEntityManager()))->createSchema();
        if ($platform->supportsSchemas()) {
            $namespaceName = $platform->getDefaultSchemaName();
            $toSchema->hasNamespace($namespaceName) || $toSchema->createNamespace($namespaceName);
        }

        // Not using value from options, because filters can be set from config.yml
        if ($filterExpression = $connection->getConfiguration()->getFilterSchemaAssetsExpression()) {
            foreach ($toSchema->getTables() as $table) {
                $tableName   = $table->getName();
                $resolvedName= $this->resolveTableName($table->getName());
                $isFiltered  = ($filterExpression && !preg_match($filterExpression, $resolvedName));
                if ($isFiltered) {
                    $toSchema->dropTable($tableName);
                }
            }
        }

        $migrationsTableName = $configuration->getMigrationsTableName();
        foreach ($fromSchema->getTables() as $table) {
            $tableName   = $table->getName();
            $resolvedName= $this->resolveTableName($table->getName());
            $isProtected = in_array($resolvedName, [$migrationsTableName]);
            if ($isProtected) {
                $fromSchema->dropTable($tableName);
            }
        }

        $up   = $this->buildCodeFromSql($fromSchema->getMigrateToSql($toSchema, $platform));
        $down = $this->buildCodeFromSql($fromSchema->getMigrateFromSql($toSchema, $platform));

        if (! $up && ! $down) {
            $output->writeln('No changes detected in your mapping information.', 'ERROR');
            return;
        }

        $path = $this->generateMigration($configuration, $input, $this->version, $up, $down);

        $output->writeln(sprintf('Generated new migration class to "<info>%s</info>" from schema differences.', $path));
    }

    protected function generateMigration(Configuration $configuration, InputInterface $input, $version, $up = null, $down = null)
    {
        $placeHolders = [
            '<class>',
            '<up>',
            '<down>',
        ];
        $replacements = [
            $input->getArgument('classname'),
            $up   ? "        " . implode("\n        ", explode("\n", $up))   : null,
            $down ? "        " . implode("\n        ", explode("\n", $down)) : null,
        ];
        $code = str_replace($placeHolders, $replacements, $this->loadTemplate($input));
        $code = preg_replace('/^ +$/m', '', $code);
        $migrationDirectoryHelper = new MigrationDirectoryHelper($configuration);
        $dir  = $migrationDirectoryHelper->getMigrationDirectory();
        $path = $dir . '/' . Util::mapClassNameToFileName($input->getArgument('classname'));

        file_put_contents($path, $code);

        if ($editorCmd = $input->getOption('editor-cmd')) {
            proc_open($editorCmd . ' ' . escapeshellarg($path), [], $pipes);
        }

        return $path;
    }

    private function buildCodeFromSql(array $sql)
    {
        return implode(PHP_EOL, array_map(function ($query) {
            return sprintf('$this->execute(%s);', var_export($query, true));
        }, $sql));
    }

    /**
     * @return ContainerInterface
     */
    private function getContainer()
    {
        return $this->getApplication()->getKernel()->getContainer();
    }

    private function resolveTableName($name)
    {
        $pos = strpos($name, '.');

        return false === $pos ? $name : substr($name, $pos + 1);
    }
}
